<!doctype html>
<html><head>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Click and Drag demo" />

<title>Click and Drag demo</title>

<style>
	body {
		background: #1b1b1b;
		color: #fff;
	}

	pre {
		color: #fcc;
	}
</style>

</head><body>
<h2>Click N Drag</h2>
This example illustrates how to do interactive click-and-drag of objects in HTML,
using plain-old DOM events like mousedown and mouseleave.
WITHOUT having to use the drag&drop API.</p>

<p>
So, normally, the user can move the mouse around without clicking and no physicist names are disturbed.
The user expects to click down on a physicist, drag it to some kind of destination, and let go.
The user might also want to cancel the operation after clicking down,
so most of the surface should NOT be a place that's an active slot.</p>

<p>
First, decide upon what elements do what.
You'll have one or more objects that the user can drag around (physicist names in this example)
and one or more slot targets that the user can drag them into.</p>

<p>
Your objects need  a mousedown handler, cuz the user will be clicking down on them.
<pre>
	physicistElements.forEach(physicist => {
		physicist.addEventListener('mousedown', mouseDownHandler);
	});
</pre>

The mousedown handler sets everything up for dragging.
The original clickdown physicist is kept around,
but we make a clone of it for the ghost - the image of what the user thinks they're dragging.
<pre>
let arenaElement;
let physicistElements;
let slotElements;
let originalElement;
let targetSlot;

function mouseDownHandler(ev) {
	originalElement = ev.target;
	ghostElement = originalElement.cloneNode(true);
	ghostElement.classList.add('ghost')
	arenaUl.append(ghostElement);
	originalElement.classList.add('original');

	arenaElement.style.cursor = 'grabbing';

	// we need the clickdown location, relative to the upper left corner of the physicist's margin
	ghostOffsetX = ev.offsetX + 13;
	ghostOffsetY = ev.offsetY + 13;

	setGhostLocation(ev);
}
</pre>

<p>So all the mouse events have a few things in common:
they all contain the coordinates of the mouse,
and you have to move the ghost to match.
So this does stuff that all the mouse handlers need to do.</p>
<pre>
let ghostElement;
let ghostUl;
let ghostOffsetX;
let ghostOffsetY;

function setGhostLocation(ev) {
	ghostElement.style.left = `${ev.pageX - ghostOffsetX}px`;
	ghostElement.style.top = `${ev.pageY - ghostOffsetY}px`;

	// no text selections!  we need this for all the events
	ev.stopPropagation();
	ev.preventDefault();
}
</pre>

<p>
The browser will send mouse move events, always, as long as the handler's set up and all.
Even if the mouse isn't down.  Even if the browser window isn't in front.
Mouse move events might come in a hundred per second, or even faster.
But, it's highly variable.
Conditions might include, how much work your handler does,
or how much overhead you have elsewhere on your page or your computer.
Or, what model of computer you have, as machines get faster over the years.
Never measure anything by the number of mouse move events, or their frequency --
only by the linear distance as given by the x and y coordinates.
Or, possibly, by timestamps from the events.</p>
<pre>
function mouseMoveHandler(ev) {
	if (ghostElement && (ev.buttons & 1)) {
		setGhostLocation(ev);
	}
}
</pre>

<p>
Eventually, the drag must come to an end.
Typically, the user just lets go on the mouse.
But, if the user drags it out of the arena, you won't get the mouseup event,
the new mouse location will get the mouseup.
(And it probably will get ignored.)
So this is also the mouseleave handler.
You have to make sure that drag mode ends before the mouse slips away,
and all the things that were set in the mouseDown handler get closed or reset.
Also, get rid of the ghost element to indicate you're not in the middle of a drag.</p>
<pre>
function mouseUpHandler(ev) {
	// ev.buttons has already been set to zero
	if (ghostElement) {
		setGhostLocation(ev);

		// do we do it?  Only if they've been dragging over a slot
		if (targetSlot) {
			moveAPhysicist(originalElement.dataset.physicist, targetSlot.dataset.slot)
		}

		// remove any slot hiliting, like user dragged out of it
		leaveSlotHandler(ev);

		originalElement.classList.remove('original');

		arenaElement.style.cursor = '';

		ghostElement.remove();
		ghostElement = null;
	}
}
</pre>


<h3> Things to try</h3>

<p>
You can do exactly the same things with PointerEvents as with MouseEvents.
Simply global replace `mouse` with `pointer`.
They work exactly the same, although pointer events have more features.</p>

<p>
Instead of having move and up listeners in the arena set all the time,
you can add them in the mousedown handler, and then remove them in the mouseup handler.</p>

<p>
Instead of putting mousemove and mouseup handlers on the page body,
you can use `setPointerCapture()` to funnel all the move and other mouse events to the original element.
You need to supply the pointer ID which is only available on pointer events,
so you have to switch to pointer event handling.
Then you can add pointermove and pointerup handlers to the original clickdown object.
Capture mode ends by itself when the user releases.</p>

<p>
The animation for picking up an object, dragging it over the page, and setting it down, can do anything you want.  </p>

<p>
In this program, whenever I use it, I get this awkward feeling when I drop a physicist into a new location,
because the others shuffle around instantly, but I can't see that motion.
It would be nice to have the items move around by themselves, slowly, so the user can see.
The way it is now, the physicist boxes don't actually rearrange, just the text inside them.
So the user is actually rearranging the data in the <tt>physicists</tt> table.
Instead, you could move around the &lt;li&gt; elements themselves; and leave the text in each.
In fact, you don't even have to use &lt;li&gt; and &lt;li&gt; elements,
but for disabled people, it's better to keep the 'list' semantics.</p>

<p>
Instead of having the physicists and slots laid out normally, make them all absolutely positioned.
You can use the Transitions CSS properties to smooth out motions to nice animations;
in this case the transition-properties would be left or right, and top or bottom.
You must do the calculations for all the locations of items and slots.
When the user actually changes the order of the items, change the coordinates to the new locations.
Transitions will smooth out the motions.
Cool!

</p>

</body></html>

